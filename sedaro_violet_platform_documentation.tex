\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{longtable}
\usepackage{booktabs}

% Page setup
\geometry{margin=1in}
\pagestyle{fancy}
\fancyhf{}
\rhead{Sedaro Violet Platform}
\lhead{Technical Documentation}
\rfoot{\thepage}

% Code listing setup
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    backgroundcolor=\color{gray!10},
    showstringspaces=false,
    tabsize=2
}

% Title formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}

\begin{document}

\title{\Huge\textbf{Sedaro Violet Platform}\\\large Technical Implementation Documentation}
\author{Violet Labs Development Team}
\date{\today}
\maketitle

\tableofcontents
\newpage

\section{Executive Summary}

The Sedaro Violet Platform is a comprehensive Flask-based web application that provides an intuitive interface for managing and simulating Sedaro agent templates. The platform features a sophisticated spreadsheet-like interface for parameter management, real-time simulation monitoring, interactive template exploration, and robust state persistence. Built with modern web technologies, it serves as a bridge between complex simulation parameters and user-friendly interface design.

\section{Architecture Overview}

\subsection{Technology Stack}
\begin{itemize}
    \item \textbf{Backend}: Flask 2.x (Python web framework)
    \item \textbf{Frontend}: HTML5, CSS3, Vanilla JavaScript (ES6+)
    \item \textbf{API Client}: Sedaro Python SDK
    \item \textbf{State Management}: Browser localStorage with automatic persistence
    \item \textbf{Styling}: Custom CSS with Violet Labs branding (\#c3adff primary)
    \item \textbf{Deployment}: Standalone Flask server (port 5000)
\end{itemize}

\subsection{Core Components}
\begin{enumerate}
    \item \textbf{Agent Template Management System} - Direct Sedaro API integration
    \item \textbf{Interactive Template Explorer} - Visual property editing interface
    \item \textbf{BOM Spreadsheet Interface} - Parameter management with auto-trigger
    \item \textbf{Simulation Control System} - Real-time monitoring and control
    \item \textbf{State Persistence Layer} - Automatic data recovery
    \item \textbf{Property Tracking System} - Visual management of tracked properties
\end{enumerate}

\section{Configuration and Setup}

\subsection{Environment Configuration}
The platform requires the following configuration constants:

\begin{lstlisting}[language=Python, caption=Platform Configuration]
API_KEY = "PKDqMrtcTK4plJgL7qVlQD.0xQph1lyKzd-pV0-ZL7bRIH7BX54Yjqbz6tluwut3Hvp8XE-RVbfHSz2o5vC77scUhg2xBFuBybplxY6FyXXMQ"
TEMP_AGENT_REPO_BRANCH_ID = "PS5ZPCp6mh5yXLH3lkCWFj"  # Template repository
SCENARIO_BRANCH_VERSION_ID = "PRx5rSwrGfkK4n9vFXmVbt"  # Simulation scenario
WORKSPACE_ID = "PQtnGZNNPdzZM5JdVhP5P9"  # Violet/Ethereal workspace
\end{lstlisting}

\subsection{Initialization Process}
\begin{lstlisting}[language=Python, caption=Platform Initialization]
# Define modules
sedaro = SedaroApiClient(api_key=API_KEY)
agent_template_branch = sedaro.agent_template(TEMP_AGENT_REPO_BRANCH_ID)
\end{lstlisting}

\section{Core Features Implementation}

\subsection{1. Agent Template Management System}

\textbf{Purpose}: Direct integration with Sedaro agent templates for real-time property management and structure exploration.

\textbf{Key Functions}:
\begin{itemize}
    \item \texttt{refresh\_agent\_template()} - Dynamic template switching
    \item \texttt{get\_agent\_template\_structure()} - Complete data structure access
    \item \texttt{discover\_blocks()} - Automatic block discovery and categorization
\end{itemize}

\begin{lstlisting}[language=Python, caption=Template Structure Management]
def get_agent_template_structure() -> Dict[str, Any]:
    """Get the complete structure of the agent template data for dropdown exploration"""
    try:
        agent_data = agent_template_branch.data
        return {
            'success': True,
            'data': agent_data,
            'keys': list(agent_data.keys()) if isinstance(agent_data, dict) else []
        }
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }

def discover_blocks() -> Dict[str, List[Dict[str, Any]]]:
    """Discover all blocks in the agent template and categorize them by type"""
    blocks_by_type = {}
    
    try:
        agent_data = agent_template_branch.data
        all_blocks = []
        
        # Multiple data structure support
        if 'blocks' in agent_data:
            all_blocks = agent_data['blocks']
        elif 'data' in agent_data and 'blocks' in agent_data['data']:
            all_blocks = agent_data['data']['blocks']
        else:
            # Fallback to known block IDs
            known_block_ids = [
                'PK3PCpCJRn6LpwvhWzNtsb',  # battery_cell_id
                'PRx5qGqQD59tCW4V9tBGQb',  # battery_pack_id
                'PRx7YwymYJgtlTDBjPKfJG',  # RCS_Z_id
                'PRybmF9qkFSZFVf2gxYSk5',  # RCS_Y_id
                'PRybm3zT77x3kCSSYHCKgG',  # RCS_X_id
            ]
            
            for block_id in known_block_ids:
                try:
                    block = agent_template_branch.block(block_id)
                    block_data = block.data
                    block_type = block_data.get('type', 'Unknown')
                    
                    if block_type not in blocks_by_type:
                        blocks_by_type[block_type] = []
                    
                    filtered_data = {k: v for k, v in block_data.items() 
                                   if not k.startswith('_')}
                    
                    blocks_by_type[block_type].append({
                        'id': block_id,
                        'name': block_data.get('name', f'{block_type}_{block_id}'),
                        'data': filtered_data,
                        'type': block_type
                    })
                except Exception as e:
                    print(f"Could not access block {block_id}: {e}")
    
    except Exception as e:
        print(f"Error discovering blocks: {e}")
        blocks_by_type = {}
    
    return blocks_by_type
\end{lstlisting}

\textbf{Features}:
\begin{itemize}
    \item Dynamic template connection management
    \item Automatic block discovery and categorization
    \item Fallback to known block IDs for reliability
    \item Comprehensive error handling and logging
    \item Support for multiple data structure formats
\end{itemize}

\subsection{2. Interactive Template Explorer}

\textbf{Purpose}: Visual interface for exploring and editing template properties with real-time mutability detection.

\textbf{Key Functions}:
\begin{itemize}
    \item \texttt{get\_property\_mutability()} - Property editability detection
    \item \texttt{update\_block\_property()} - Direct block property updates
    \item \texttt{update\_root\_property()} - Root-level property management
\end{itemize}

\begin{lstlisting}[language=Python, caption=Property Management System]
def get_property_mutability(block_id: Optional[str] = None, property_name: Optional[str] = None) -> Dict[str, Any]:
    """Check if a property is mutable by attempting to get its metadata or trying a test update"""
    try:
        if block_id:
            # For block properties
            block = agent_template_branch.block(block_id)
            block_data = block.data
            
            if property_name not in block_data:
                return {
                    'success': False,
                    'error': f'Property {property_name} not found in block {block_id}'
                }
            
            # Check for immutable system properties
            immutable_properties = ['id', 'type', '_id', '_type', '_version', '_created', '_updated']
            is_mutable = property_name not in immutable_properties
            
            return {
                'success': True,
                'mutable': is_mutable,
                'reason': 'Immutable system property' if not is_mutable else 'Editable property'
            }
        else:
            # For root properties
            agent_data = agent_template_branch.data
            
            if property_name not in agent_data:
                return {
                    'success': False,
                    'error': f'Root property {property_name} not found'
                }
            
            immutable_root_properties = ['_id', '_type', '_version', '_created', '_updated']
            is_mutable = property_name not in immutable_root_properties
            
            return {
                'success': True,
                'mutable': is_mutable,
                'reason': 'Immutable system property' if not is_mutable else 'Editable property'
            }
            
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }

def update_block_property(block_id: str, property_name: str, new_value: Any) -> Dict[str, Any]:
    """Update a specific property of a block using Sedaro client directly"""
    try:
        block = agent_template_branch.block(block_id)
        block.update(**{property_name: new_value})
        
        updated_value = getattr(block, property_name, new_value)
        
        return {
            'success': True,
            'message': f'Successfully updated {property_name} to {updated_value}',
            'updated_value': updated_value
        }
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }
\end{lstlisting}

\textbf{Features}:
\begin{itemize}
    \item Real-time mutability detection for UI feedback
    \item Automatic type conversion (string to number/boolean)
    \item Comprehensive error handling with user-friendly messages
    \item Support for both block and root-level properties
    \item Direct Sedaro client integration for immediate updates
\end{itemize}

\subsection{3. BOM Spreadsheet Interface}

\textbf{Purpose}: Advanced spreadsheet-like interface for managing input variables and associating them with template properties, featuring auto-trigger simulation capabilities.

\textbf{Key Components}:
\begin{itemize}
    \item Dynamic row management with unique IDs
    \item Property association via hierarchical dropdown
    \item Auto-trigger simulation system
    \item Real-time value validation and type conversion
    \item State persistence and restoration
\end{itemize}

\begin{lstlisting}[language=JavaScript, caption=Spreadsheet Row Management]
function addSpreadsheetRow(restoreRowId = null, restoreData = null) {
    const tbody = document.getElementById('bomTableBody');
    const rowId = restoreRowId || Math.floor(Math.random() * 1000000);
    
    const row = document.createElement('tr');
    row.id = `row-${rowId}`;
    row.innerHTML = `
        <td>
            <input type="text" class="spreadsheet-input" placeholder="Variable name" 
                   onchange="updateSpreadsheetData('${rowId}', 'name', this.value)">
        </td>
        <td>
            <input type="text" class="spreadsheet-input" placeholder="Input value" 
                   onchange="updateSpreadsheetData('${rowId}', 'value', this.value)">
        </td>
        <td>
            <div class="property-selector">
                <input type="text" placeholder="Click to select template property" readonly
                       onclick="showPropertyDropdown('${rowId}')">
                <div class="property-dropdown" id="dropdown-${rowId}"></div>
            </div>
        </td>
        <td>
            <label class="toggle-container-small">
                <input type="checkbox" id="autoTrigger-${rowId}" 
                       onchange="updateSpreadsheetData('${rowId}', 'autoTrigger', this.checked)">
                <span class="toggle-slider-small"></span>
            </label>
        </td>
        <td>
            <div class="action-buttons">
                <button class="action-btn save" onclick="saveProperty('${rowId}')">
                    üíæ Save
                </button>
                <button class="action-btn delete" onclick="deleteRow('${rowId}')">
                    üóëÔ∏è
                </button>
            </div>
        </td>
    `;
    
    tbody.appendChild(row);
    
    // Initialize data structure
    if (restoreData) {
        spreadsheetData[rowId] = restoreData;
        // Restore input values
        const nameInput = row.querySelector('td:nth-child(1) input');
        const valueInput = row.querySelector('td:nth-child(2) input');
        const propertyInput = row.querySelector('td:nth-child(3) input');
        
        if (nameInput && restoreData.name) nameInput.value = restoreData.name;
        if (valueInput && restoreData.value) valueInput.value = restoreData.value;
        if (propertyInput && restoreData.associatedProperty) {
            propertyInput.value = restoreData.associatedProperty.displayName;
        }
    } else {
        spreadsheetData[rowId] = {
            name: '',
            value: '',
            associatedProperty: null,
            autoTrigger: false,
            lastAppliedValue: null
        };
    }
}
\end{lstlisting}

\textbf{Property Association System}:
\begin{lstlisting}[language=JavaScript, caption=Property Dropdown System]
function showPropertyDropdown(rowId) {
    const dropdown = document.getElementById(`dropdown-${rowId}`);
    
    // Clear previous content
    dropdown.innerHTML = '';
    
    // Add search functionality
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.placeholder = 'Search properties...';
    searchInput.className = 'spreadsheet-input';
    searchInput.style = 'margin-bottom: 8px;';
    searchInput.onkeyup = function() {
        filterPropertyDropdown(dropdown, this.value);
    };
    dropdown.appendChild(searchInput);
    
    // Group properties by type
    const rootProperties = allTemplateProperties.filter(p => !p.isBlock && !p.blockId);
    const blockProperties = allTemplateProperties.filter(p => p.isBlock);
    const drilledProperties = allTemplateProperties.filter(p => !p.isBlock && p.blockId);
    
    // Add root properties
    if (rootProperties.length > 0) {
        const rootHeader = document.createElement('div');
        rootHeader.className = 'property-item';
        rootHeader.style = 'background: #f8f9fa; font-weight: bold; color: #495057;';
        rootHeader.innerHTML = '<div>üåê Root Properties</div>';
        dropdown.appendChild(rootHeader);
        
        rootProperties.forEach(prop => {
            const item = document.createElement('div');
            item.className = 'property-item';
            item.style = 'padding-left: 20px;';
            item.innerHTML = `
                <div>${prop.displayName}</div>
                <div class="property-path">${prop.path}</div>
            `;
            item.onclick = function(e) {
                e.stopPropagation();
                selectProperty(rowId, prop);
            };
            dropdown.appendChild(item);
        });
    }
    
    // Add drilled-down block properties
    if (drilledProperties.length > 0) {
        const blockHeader = document.createElement('div');
        blockHeader.className = 'property-item';
        blockHeader.style = 'background: #f8f9fa; font-weight: bold; color: #495057;';
        blockHeader.innerHTML = '<div>üîß Block Properties</div>';
        dropdown.appendChild(blockHeader);
        
        drilledProperties.forEach(prop => {
            const item = document.createElement('div');
            item.className = 'property-item';
            item.style = 'padding-left: 20px;';
            item.innerHTML = `
                <div>${prop.displayName}</div>
                <div class="property-path">${prop.path}</div>
            `;
            item.onclick = function(e) {
                e.stopPropagation();
                selectProperty(rowId, prop);
            };
            dropdown.appendChild(item);
        });
    }
    
    dropdown.style.display = 'block';
}
\end{lstlisting}

\textbf{Features}:
\begin{itemize}
    \item Hierarchical property organization (Root, Block, Drilled)
    \item Real-time search and filtering
    \item Expandable block components
    \item Auto-trigger toggle per row
    \item Visual feedback for property associations
    \item Comprehensive error handling
\end{itemize}

\subsection{4. Auto-Trigger Simulation System}

\textbf{Purpose}: Intelligent simulation triggering system that automatically starts simulations when tracked properties change, with comprehensive error handling and validation.

\begin{lstlisting}[language=JavaScript, caption=Auto-Trigger Implementation]
async function applySpreadsheetChanges() {
    let hasChanges = false;
    let hasErrors = false;
    
    for (const [rowId, data] of Object.entries(spreadsheetData)) {
        // Only process rows that have auto-trigger enabled
        if (data.autoTrigger && data.name && data.value && data.associatedProperty) {
            const currentValue = parseValue(data.value);
            const lastValue = data.lastAppliedValue;
            
            // Check if value has actually changed locally
            if (JSON.stringify(currentValue) !== JSON.stringify(lastValue)) {
                try {
                    let updateResponse;
                    
                    if (data.associatedProperty.isBlock) {
                        // Update block property
                        updateResponse = await fetch('/api/update_property', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                block_id: data.associatedProperty.id,
                                property_name: data.associatedProperty.name,
                                new_value: currentValue
                            })
                        });
                    } else if (data.associatedProperty.blockId) {
                        // Update block property (drilled down)
                        updateResponse = await fetch('/api/update_property', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                block_id: data.associatedProperty.blockId,
                                property_name: data.associatedProperty.name,
                                new_value: currentValue
                            })
                        });
                    } else {
                        // Update root property
                        updateResponse = await fetch('/api/update_root_property', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                property_name: data.associatedProperty.name,
                                new_value: currentValue
                            })
                        });
                    }
                    
                    const updateResult = await updateResponse.json();
                    
                    if (updateResult.success) {
                        // Check if the property actually changed on the server
                        const actualChanged = updateResult.updated_value !== data.lastAppliedValue;
                        
                        if (actualChanged) {
                            hasChanges = true;
                            showToast(`Updated ${data.name} to ${data.value}`, 'success');
                        } else {
                            showToast(`No change needed for ${data.name}`, 'info');
                        }
                        
                        // Update last applied value with the actual server value
                        spreadsheetData[rowId].lastAppliedValue = updateResult.updated_value;
                    } else {
                        hasErrors = true;
                        showToast(`Failed to update ${data.name}: ${updateResult.error}`, 'error');
                    }
                } catch (error) {
                    hasErrors = true;
                    showToast(`Failed to update ${data.name}: ${error.message}`, 'error');
                }
            }
        }
    }
    
    // Only trigger simulation if we actually had changes AND no errors occurred
    if (hasChanges && !hasErrors) {
        setTimeout(() => {
            startSimulation();
        }, 1000); // Small delay to ensure all updates are processed
    } else if (hasErrors) {
        showToast('Simulation skipped due to update errors', 'error');
    }
}
\end{lstlisting}

\textbf{Features}:
\begin{itemize}
    \item Per-row auto-trigger configuration
    \item Change detection and validation
    \item Comprehensive error handling
    \item Conditional simulation triggering
    \item User feedback through toast notifications
    \item Server-side value verification
\end{itemize}

\subsection{5. Real-Time Simulation Monitoring}

\textbf{Purpose}: Non-blocking simulation progress monitoring with automatic polling, timeout protection, and detailed progress reporting.

\begin{lstlisting}[language=JavaScript, caption=Simulation Monitoring System]
function startProgressMonitoring(simulationId) {
    // Clear any existing interval
    if (progressInterval) {
        clearInterval(progressInterval);
    }
    
    // Update immediately
    updateProgress(simulationId);
    
    // Then update every 2 seconds
    progressInterval = setInterval(async () => {
        const isComplete = await updateProgress(simulationId);
        if (isComplete) {
            clearInterval(progressInterval);
            progressInterval = null;
        }
    }, 2000);
    
    // Safety timeout: stop polling after 30 minutes
    setTimeout(() => {
        if (progressInterval) {
            console.warn('Stopping simulation monitoring due to timeout (30 minutes)');
            clearInterval(progressInterval);
            progressInterval = null;
            showToast('Simulation monitoring stopped due to timeout', 'info');
            
            const statusText = document.getElementById('statusText');
            if (statusText) {
                statusText.textContent = '‚è∞ Simulation monitoring timed out after 30 minutes';
            }
        }
    }, 30 * 60 * 1000); // 30 minutes
}

async function updateProgress(simulationId) {
    try {
        const response = await fetch(`/api/simulation_status?simulation_id=${simulationId}`);
        const result = await response.json();
        
        if (result.success) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const statusText = document.getElementById('statusText');
            const progressDetails = document.getElementById('progressDetails');
            
            // Update progress bar
            const progress = result.progress || 0;
            progressFill.style.width = `${progress}%`;
            progressText.textContent = `${Math.round(progress)}%`;
            
            // Update status text
            statusText.textContent = result.message;
            
            // Update detailed progress information if available
            if (result.progress_info && result.status === 'RUNNING') {
                const currentTime = document.getElementById('currentTime');
                const timeRange = document.getElementById('timeRange');
                const minTimeStep = document.getElementById('minTimeStep');
                
                if (result.progress_info.currentTime !== undefined) {
                    currentTime.textContent = result.progress_info.currentTime.toFixed(1);
                }
                
                if (result.progress_info.startTime !== undefined && result.progress_info.stopTime !== undefined) {
                    timeRange.textContent = `${result.progress_info.startTime.toFixed(1)} - ${result.progress_info.stopTime.toFixed(1)}`;
                }
                
                if (result.progress_info.minTimeStep !== undefined) {
                    minTimeStep.textContent = result.progress_info.minTimeStep.toExponential(1);
                }
                
                progressDetails.style.display = 'block';
            } else {
                progressDetails.style.display = 'none';
            }
            
            // Check if simulation is complete
            if (result.is_complete) {
                if (result.status === 'SUCCEEDED') {
                    statusText.textContent = '‚úÖ Simulation completed successfully!';
                    showToast('Simulation completed successfully!', 'success');
                } else {
                    statusText.textContent = `‚ùå Simulation ${result.status.toLowerCase()}`;
                    showToast(`Simulation ${result.status.toLowerCase()}`, 'error');
                }
                
                // Hide progress bar and abort button, but keep status message
                const progressBar = document.querySelector('.progress-container');
                const abortBtn = document.getElementById('abortBtn');
                if (progressBar) progressBar.style.display = 'none';
                if (abortBtn) abortBtn.style.display = 'none';
                
                // Reset simulation ID to allow new simulations
                currentSimulationId = null;
                
                return true; // Stop polling
            }
            
            return false; // Continue polling
        } else {
            console.error('Failed to get simulation status:', result.error);
            showToast('Failed to get simulation status, stopping monitoring', 'error');
            return true; // Stop polling
        }
    } catch (error) {
        console.error('Error checking simulation status:', error);
        showToast('Error checking simulation status, stopping monitoring', 'error');
        return true; // Stop polling
    }
}
\end{lstlisting}

\textbf{Features}:
\begin{itemize}
    \item Non-blocking progress updates every 2 seconds
    \item 30-minute safety timeout to prevent infinite polling
    \item Detailed progress information display
    \item Automatic UI state management
    \item Comprehensive error handling
    \item Simulation completion detection
\end{itemize}

\subsection{6. State Persistence System}

\textbf{Purpose}: Robust state persistence system that prevents data loss on page refresh and provides seamless user experience recovery.

\begin{lstlisting}[language=JavaScript, caption=State Persistence Implementation]
function saveState() {
    const state = {
        currentSimulationId: currentSimulationId,
        spreadsheetData: spreadsheetData,
        autoSimEnabled: document.getElementById('autoSimToggle')?.checked || false
    };
    localStorage.setItem('sedaroVioletState', JSON.stringify(state));
}

function loadState() {
    try {
        const savedState = localStorage.getItem('sedaroVioletState');
        if (savedState) {
            const state = JSON.parse(savedState);
            
            // Restore simulation ID
            if (state.currentSimulationId) {
                currentSimulationId = state.currentSimulationId;
                // Check if simulation is still running
                checkAndRestoreSimulation(state.currentSimulationId);
            }
            
            // Restore spreadsheet data
            if (state.spreadsheetData) {
                spreadsheetData = state.spreadsheetData;
                restoreSpreadsheetUI();
            }
            
            // Restore auto-sim toggle
            if (state.autoSimEnabled !== undefined) {
                const autoSimToggle = document.getElementById('autoSimToggle');
                if (autoSimToggle) {
                    autoSimToggle.checked = state.autoSimEnabled;
                }
            }
            
            console.log('State restored from localStorage');
        }
    } catch (error) {
        console.error('Error loading state:', error);
        // Clear corrupted state
        localStorage.removeItem('sedaroVioletState');
    }
}

async function checkAndRestoreSimulation(simulationId) {
    try {
        const response = await fetch(`/api/simulation_status?simulation_id=${simulationId}`);
        const result = await response.json();
        
        if (result.success && !result.is_complete) {
            // Simulation is still running, restore progress monitoring
            const progressDiv = document.getElementById('simulationProgress');
            if (progressDiv) {
                progressDiv.style.display = 'block';
            }
            startProgressMonitoring(simulationId);
            showToast('Restored simulation monitoring', 'info');
        } else {
            // Simulation is complete or doesn't exist, clear the ID
            currentSimulationId = null;
            saveState();
        }
    } catch (error) {
        console.error('Error checking simulation status:', error);
        currentSimulationId = null;
        saveState();
    }
}

function setupStatePersistence() {
    // Save state every 5 seconds
    setInterval(saveState, 5000);
    
    // Save state on page unload
    window.addEventListener('beforeunload', saveState);
    
    // Save state when spreadsheet data changes
    const originalUpdateSpreadsheetData = updateSpreadsheetData;
    updateSpreadsheetData = function(rowId, field, value) {
        originalUpdateSpreadsheetData(rowId, field, value);
        saveState();
    };
}
\end{lstlisting}

\textbf{Features}:
\begin{itemize}
    \item Automatic state saving every 5 seconds
    \item State restoration on page load
    \item Simulation state recovery and monitoring restoration
    \item Spreadsheet data persistence with UI restoration
    \item Error handling for corrupted state data
    \item Page unload state preservation
\end{itemize}

\subsection{7. Property Tracking System}

\textbf{Purpose}: Visual management system for tracked properties with real-time status display and management capabilities.

\begin{lstlisting}[language=JavaScript, caption=Property Tracking Display]
function updateTrackedPropertiesDisplay() {
    const container = document.getElementById('trackedPropertiesContainer');
    const noTrackedDiv = document.getElementById('noTrackedProperties');
    
    if (!container) return;
    
    // Get tracked properties (rows with associated properties) - prevent duplicates
    const trackedProperties = [];
    const seenProperties = new Set(); // Track unique property associations
    
    for (const [rowId, data] of Object.entries(spreadsheetData)) {
        if (data.name && data.associatedProperty) {
            // Create a unique key for this property association using name and block ID
            const propertyKey = `${data.associatedProperty.blockId || 'root'}-${data.associatedProperty.name}`;
            
            // Only add if we haven't seen this property before
            if (!seenProperties.has(propertyKey)) {
                seenProperties.add(propertyKey);
                trackedProperties.push({
                    rowId: rowId,
                    ...data
                });
            }
        }
    }
    
    if (trackedProperties.length === 0) {
        container.innerHTML = '';
        if (noTrackedDiv) noTrackedDiv.style.display = 'block';
        return;
    }
    
    if (noTrackedDiv) noTrackedDiv.style.display = 'none';
    
    let html = '';
    trackedProperties.forEach(prop => {
        // Check if this property has auto-trigger enabled (per-row setting)
        const hasAutoTrigger = prop.autoTrigger && prop.value && prop.value.trim() !== '';
        
        html += `
            <div class="tracked-property-block">
                <div class="tracked-property-header">
                    <div class="tracked-property-name">
                        ${prop.name}
                        ${hasAutoTrigger ? '<span class="auto-trigger-badge">üîÑ Auto</span>' : ''}
                    </div>
                    <div class="tracked-property-actions">
                        <button class="edit-btn" onclick="editTrackedProperty('${prop.rowId}')">
                            ‚úèÔ∏è Edit
                        </button>
                        <button class="delete-btn" onclick="deleteTrackedProperty('${prop.rowId}')">
                            üóëÔ∏è Stop Tracking
                        </button>
                    </div>
                </div>
                <div class="tracked-property-details">
                    <div class="tracked-property-item">
                        <div class="tracked-property-label">Variable Name</div>
                        <div class="tracked-property-value">${prop.name}</div>
                    </div>
                    <div class="tracked-property-item">
                        <div class="tracked-property-label">Current Value</div>
                        <div class="tracked-property-value">${prop.value || 'Not set'}</div>
                    </div>
                    <div class="tracked-property-item">
                        <div class="tracked-property-label">Template Property</div>
                        <div class="tracked-property-value">${prop.associatedProperty.displayName}</div>
                    </div>
                    <div class="tracked-property-item">
                        <div class="tracked-property-label">Last Applied Value</div>
                        <div class="tracked-property-value">${prop.lastAppliedValue !== null ? prop.lastAppliedValue : 'Not applied'}</div>
                    </div>
                    <div class="tracked-property-item">
                        <div class="tracked-property-label">Auto-Trigger Status</div>
                        <div class="tracked-property-value">
                            ${hasAutoTrigger ? 
                                '<span style="color: #28a745; font-weight: bold;">üîÑ Active</span>' : 
                                '<span style="color: #6c757d;">‚è∏Ô∏è Inactive</span>'
                            }
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
}
\end{lstlisting}

\textbf{Features}:
\begin{itemize}
    \item Visual property tracking dashboard
    \item Real-time status updates
    \item Auto-trigger status indicators
    \item Quick edit and stop tracking actions
    \item Duplicate property prevention
    \item Comprehensive property information display
\end{itemize}

\section{API Endpoints}

\subsection{Core Management Endpoints}

\begin{longtable}{|p{3cm}|p{2cm}|p{8cm}|}
\hline
\textbf{Endpoint} & \textbf{Method} & \textbf{Description} \\
\hline
\endhead
\hline
\endfoot
\texttt{/api/blocks} & GET & Discover and categorize all blocks in the agent template \\
\texttt{/api/template\_structure} & GET & Get complete agent template data structure \\
\texttt{/api/refresh\_template} & POST & Refresh agent template connection with optional new template ID \\
\texttt{/api/block/<id>/properties} & GET & Get properties of a specific block \\
\texttt{/api/mutability} & GET & Check if a property is mutable (block or root level) \\
\texttt{/api/explore\_path} & POST & Explore specific path in template data structure \\
\hline
\end{longtable}

\subsection{Property Management Endpoints}

\begin{longtable}{|p{3cm}|p{2cm}|p{8cm}|}
\hline
\textbf{Endpoint} & \textbf{Method} & \textbf{Description} \\
\hline
\endhead
\hline
\endfoot
\texttt{/api/update\_property} & POST & Update a specific block property \\
\texttt{/api/update\_root\_property} & POST & Update a root-level template property \\
\hline
\end{longtable}

\subsection{Simulation Control Endpoints}

\begin{longtable}{|p{3cm}|p{2cm}|p{8cm}|}
\hline
\textbf{Endpoint} & \textbf{Method} & \textbf{Description} \\
\hline
\endhead
\hline
\endfoot
\texttt{/api/simulate} & POST & Start a new simulation \\
\texttt{/api/simulation\_status} & GET & Get simulation progress and status \\
\texttt{/api/abort\_simulation} & POST & Abort a running simulation \\
\texttt{/api/results} & GET & Get simulation results and statistics \\
\hline
\end{longtable}

\section{User Interface Features}

\subsection{Visual Design System}

\textbf{Color Scheme}:
\begin{itemize}
    \item \textbf{Primary}: \#c3adff (Violet Labs purple)
    \item \textbf{Secondary}: \#a78bfa (Darker purple)
    \item \textbf{Success}: \#28a745 (Green)
    \item \textbf{Error}: \#dc3545 (Red)
    \item \textbf{Info}: \#17a2b8 (Blue)
    \item \textbf{Warning}: \#ffc107 (Yellow)
\end{itemize}

\textbf{Component Styling}:
\begin{itemize}
    \item \textbf{Responsive Layout}: Mobile-friendly design with CSS Grid and Flexbox
    \item \textbf{Toast Notifications}: Real-time user feedback with smooth animations
    \item \textbf{Progress Indicators}: Visual simulation progress with detailed metrics
    \item \textbf{Interactive Elements}: Hover effects, transitions, and visual feedback
    \item \textbf{Modal Dialogs}: Property editing with validation
\end{itemize}

\subsection{User Experience Features}

\begin{itemize}
    \item \textbf{Intuitive Workflow}: Step-by-step parameter management with visual guidance
    \item \textbf{Error Prevention}: Comprehensive validation and confirmation dialogs
    \item \textbf{State Recovery}: Seamless refresh experience with automatic state restoration
    \item \textbf{Real-time Updates}: Live progress monitoring and property synchronization
    \item \textbf{Keyboard Navigation}: Full keyboard support for accessibility
    \item \textbf{Search and Filter}: Advanced property discovery and filtering
\end{itemize}

\section{Error Handling Strategy}

\subsection{Comprehensive Error Management}

\textbf{API Error Handling}:
\begin{itemize}
    \item Graceful degradation for network issues
    \item Automatic retry mechanisms for transient failures
    \item User-friendly error messages with actionable guidance
    \item Detailed error logging for debugging
\end{itemize}

\textbf{Validation Errors}:
\begin{itemize}
    \item Real-time input validation with immediate feedback
    \item Type conversion error handling
    \item Property existence verification
    \item Mutability checking before update attempts
\end{itemize}

\textbf{State Corruption Recovery}:
\begin{itemize}
    \item Automatic detection of corrupted localStorage data
    \item Graceful fallback to default state
    \item User notification of state recovery actions
    \item Prevention of cascading failures
\end{itemize}

\textbf{Simulation Failures}:
\begin{itemize}
    \item Detailed error reporting with context
    \item Automatic cleanup of failed simulation states
    \item User guidance for common failure scenarios
    \item Recovery mechanisms for interrupted simulations
\end{itemize}

\section{Performance Optimizations}

\subsection{Efficiency Measures}

\textbf{Loading Optimizations}:
\begin{itemize}
    \item Lazy loading of template properties on demand
    \item Progressive enhancement of UI components
    \item Efficient DOM manipulation with minimal reflows
    \item Optimized property discovery algorithms
\end{itemize}

\textbf{Update Optimizations}:
\begin{itemize}
    \item Debounced updates to reduce API calls during rapid changes
    \item Batch processing of multiple property updates
    \item Change detection to prevent unnecessary server requests
    \item Efficient state synchronization
\end{itemize}

\textbf{Memory Management}:
\begin{itemize}
    \item Proper cleanup of intervals and event listeners
    \item Efficient data structures for large property sets
    \item Automatic garbage collection of unused references
    \item Memory leak prevention in long-running sessions
\end{itemize}

\textbf{Caching Strategy}:
\begin{itemize}
    \item Local storage for state persistence
    \item Template structure caching
    \item Property metadata caching
    \item Simulation status caching with TTL
\end{itemize}

\section{Development Best Practices}

\subsection{Code Quality Standards}

\textbf{Modular Design}:
\begin{itemize}
    \item Separated concerns with clear function boundaries
    \item Reusable components and utility functions
    \item Consistent naming conventions
    \item Comprehensive function documentation
\end{itemize}

\textbf{Error Boundaries}:
\begin{itemize}
    \item Comprehensive try-catch blocks at all levels
    \item Graceful error recovery mechanisms
    \item User-friendly error messages
    \item Detailed error logging for debugging
\end{itemize}

\textbf{Type Safety}:
\begin{itemize}
    \item Proper data type handling and conversion
    \item Input validation and sanitization
    \item Type checking for critical operations
    \item Defensive programming practices
\end{itemize}

\textbf{Documentation}:
\begin{itemize}
    \item Inline comments for complex logic
    \item Function documentation with parameter descriptions
    \item API endpoint documentation
    \item User interface documentation
\end{itemize}

\section{Security Considerations}

\subsection{Data Protection}

\begin{itemize}
    \item \textbf{API Key Security}: Secure storage and transmission of Sedaro API keys
    \item \textbf{Input Validation}: Comprehensive validation of all user inputs
    \item \textbf{XSS Prevention}: Proper escaping of user-generated content
    \item \textbf{CSRF Protection}: Protection against cross-site request forgery
\end{itemize}

\subsection{Access Control}

\begin{itemize}
    \item \textbf{Template Access}: Validation of template access permissions
    \item \textbf{Property Modification}: Verification of property modification rights
    \item \textbf{Simulation Control}: Authorization checks for simulation operations
\end{itemize}

\section{Future Enhancements}

\subsection{Planned Features}

\textbf{Advanced Analytics}:
\begin{itemize}
    \item Simulation result analysis and visualization
    \item Performance trend tracking
    \item Comparative analysis tools
    \item Export capabilities for reports
\end{itemize}

\textbf{Enhanced Collaboration}:
\begin{itemize}
    \item Multi-user support with role-based access
    \item Real-time collaboration features
    \item Template sharing and versioning
    \item Comment and annotation systems
\end{itemize}

\textbf{Advanced Automation}:
\begin{itemize}
    \item Scheduled simulation execution
    \item Conditional simulation triggering
    \item Batch processing capabilities
    \item Integration with external systems
\end{itemize}

\textbf{Performance Monitoring}:
\begin{itemize}
    \item API rate limiting and monitoring
    \item Performance metrics collection
    \item Resource usage optimization
    \item Scalability improvements
\end{itemize}

\section{Deployment and Operations}

\subsection{Deployment Configuration}

\textbf{Environment Setup}:
\begin{itemize}
    \item Flask development server (port 5000)
    \item Static file serving for assets
    \item Environment variable configuration
    \item API key management
\end{itemize}

\textbf{Production Considerations}:
\begin{itemize}
    \item WSGI server deployment (Gunicorn/uWSGI)
    \item Reverse proxy configuration (Nginx)
    \item SSL/TLS certificate management
    \item Load balancing and scaling
\end{itemize}

\section{Conclusion}

The Sedaro Violet Platform represents a comprehensive and sophisticated solution for agent template management and simulation control. The implementation demonstrates modern web development practices with a strong focus on user experience, reliability, and maintainability.

\textbf{Key Achievements}:
\begin{itemize}
    \item \textbf{Seamless Integration}: Direct Sedaro API integration with comprehensive error handling
    \item \textbf{Intuitive Interface}: Advanced spreadsheet interface with property association capabilities
    \item \textbf{Robust State Management}: Automatic state persistence and recovery mechanisms
    \item \textbf{Real-time Monitoring}: Non-blocking simulation progress monitoring with detailed metrics
    \item \textbf{Advanced Automation}: Intelligent auto-trigger system with validation and error handling
    \item \textbf{Property Tracking}: Visual management system for tracked properties with real-time status
\end{itemize}

\textbf{Technical Excellence}:
\begin{itemize}
    \item \textbf{Modular Architecture}: Well-structured codebase with clear separation of concerns
    \item \textbf{Comprehensive Error Handling}: Multi-layered error management with user-friendly feedback
    \item \textbf{Performance Optimization}: Efficient algorithms and caching strategies
    \item \textbf{Security Considerations}: Input validation and access control mechanisms
    \item \textbf{Accessibility}: Keyboard navigation and responsive design
\end{itemize}

The platform successfully bridges the gap between complex simulation parameters and user-friendly interface design, enabling efficient workflow management for Sedaro agent templates. The combination of advanced features, robust error handling, and intuitive user experience makes it a powerful tool for simulation management and analysis.

\end{document} 